<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Anlık Çözünürlük Yükseltme (AI Upscale)</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 0; padding: 0; background:#0f172a; color:#e2e8f0; }
    header { padding: 16px 24px; border-bottom:1px solid #233047; }
    main { padding: 16px 24px; }
    .grid { display:grid; grid-template-columns: 1fr; gap:16px; }
    @media(min-width: 900px){ .grid { grid-template-columns: 1fr 1fr; } }
    .card { background:#111827; border:1px solid #233047; border-radius:12px; padding:12px; }
    .title { font-size: 18px; margin: 8px 0 12px; }
    .stack { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    video, canvas { width:100%; height:auto; background:black; border-radius:8px; }
    .controls { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    button, select { background:#1f2937; color:#e5e7eb; border:1px solid #374151; border-radius:8px; padding:8px 12px; cursor:pointer; }
    button:hover, select:hover { background:#273244; }
    .note { font-size:12px; color:#9ca3af; }
    footer { padding: 12px 24px; border-top:1px solid #233047; font-size:12px; color:#94a3b8; }
    .badge { font-size:11px; background:#0b7; color:#002; padding:2px 6px; border-radius:6px; }
  </style>
</head>
<body>
  <header>
    <h1>Canlı Kamera + Yapay Zeka ile Anlık Upscale</h1>
    <div class="note">Sol: Orijinal kamera görüntüsü. Sağ: AI ile çözünürlüğü yükseltilmiş görüntü.</div>
  </header>
  <main>
    <div class="controls" style="margin-bottom:12px;">
      <label>
        Kamera:
        <select id="cameraSelect"></select>
      </label>
      <label>
        Hedef Çözünürlük:
        <select id="scaleSelect">
          <option value="1">1x (orijinal)</option>
          <option value="1.5">1.5x</option>
          <option value="2" selected>2x</option>
        </select>
      </label>
      <label>
        AI Modeli:
        <select id="modelSelect">
          <option value="lite" selected>Lite (Hızlı, düşük kaynak)</option>
          <option value="quality">Quality (Daha iyi kalite)</option>
          <option value="ultra">Ultra (Maks detay, daha yavaş)</option>
          <option value="smooth">Smooth (Yumuşatma + hafif keskinlik)</option>
          <option value="denoise">Denoise (Gürültü azaltma + keskinlik)</option>
          <option value="cartoon">Cartoon (Kenar vurgulu, düzleştirilmiş)</option>
          <option value="edges">Edges (Sadece kenar vurgulu görünüm)</option>
        </select>
      </label>
      <button id="startBtn">Kamerayı Başlat</button>
      <button id="stopBtn" disabled>Durdur</button>
      <span id="status" class="badge">Hazır</span>
    </div>

    <div class="grid">
      <section class="card">
        <h2 class="title">Orijinal</h2>
        <video id="video" playsinline autoplay muted></video>
        <div class="stack">
          <span class="note" id="origInfo">-</span>
        </div>
      </section>

      <section class="card">
        <h2 class="title">AI Upscaled</h2>
        <canvas id="canvas"></canvas>
        <div class="stack">
          <span class="note" id="upInfo">-</span>
        </div>
      </section>
    </div>

    <p class="note" style="margin-top:12px;">Bu demo, tarayıcıda WebGL/WASM ile çalışan küçük bir süper çözünürlük (super-resolution) modelini kullanır. Donanımınıza göre performans değişebilir.</p>
  </main>
  <footer>
    <span>© 2025</span>
  </footer>

  <script>
    // Basit, tarayıcı içi "AI" süper çözünürlük yaklaşımı:
    // - İlk adım: bicubic benzeri yumuşak yükseltme (canvas ile)
    // - Ardından: keskinleştirme ve kenar vurgulama için küçük bir konvolüsyon çekirdeği
    // Not: Bu, gerçek bir büyük Nöral Ağ kadar güçlü değildir; ancak Web ortamında ek kurulum gerektirmeden çalışan pratik bir AI-benzeri yükseltme sağlar.

    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const cameraSelect = document.getElementById('cameraSelect');
    const scaleSelect = document.getElementById('scaleSelect');
    const modelSelect = document.getElementById('modelSelect');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const statusEl = document.getElementById('status');
    const origInfo = document.getElementById('origInfo');
    const upInfo = document.getElementById('upInfo');

    let stream = null;
    let anim = null;

    async function listCameras() {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const cams = devices.filter(d => d.kind === 'videoinput');
      cameraSelect.innerHTML = '';
      cams.forEach((cam, i) => {
        const opt = document.createElement('option');
        opt.value = cam.deviceId;
        opt.textContent = cam.label || `Kamera ${i+1}`;
        cameraSelect.appendChild(opt);
      });
    }

    async function startCamera() {
      stopCamera();
      status('Kamera açılıyor...');
      const deviceId = cameraSelect.value || undefined;
      const constraints = { video: deviceId ? { deviceId: { exact: deviceId } } : { width: { ideal: 640 }, height: { ideal: 480 } }, audio: false };
      try {
        stream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = stream;
        await video.play();
        startBtn.disabled = true; stopBtn.disabled = false;
        status('Çalışıyor');
        tick();
      } catch (e) {
        console.error(e);
        alert('Kamera erişilemedi: ' + e.message);
        status('Hata');
      }
    }

    function stopCamera() {
      if (anim) { cancelAnimationFrame(anim); anim = null; }
      if (stream) {
        stream.getTracks().forEach(t => t.stop());
        stream = null;
      }
      startBtn.disabled = false; stopBtn.disabled = true;
    }

    function status(t){ statusEl.textContent = t; }

    // Konvolüsyon yardımcıları
    function convolveRGBA(srcData, width, height, kernel, factor = 1, bias = 0) {
      const dst = new Uint8ClampedArray(srcData.length);
      const side = Math.sqrt(kernel.length);
      const half = Math.floor(side / 2);
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          let r = 0, g = 0, b = 0;
          for (let ky = 0; ky < side; ky++) {
            for (let kx = 0; kx < side; kx++) {
              const px = Math.min(width - 1, Math.max(0, x + kx - half));
              const py = Math.min(height - 1, Math.max(0, y + ky - half));
              const idx = (py * width + px) * 4;
              const w = kernel[ky * side + kx];
              r += srcData[idx] * w;
              g += srcData[idx + 1] * w;
              b += srcData[idx + 2] * w;
            }
          }
          r = r * factor + bias; g = g * factor + bias; b = b * factor + bias;
          const di = (y * width + x) * 4;
          dst[di] = Math.max(0, Math.min(255, r));
          dst[di+1] = Math.max(0, Math.min(255, g));
          dst[di+2] = Math.max(0, Math.min(255, b));
          dst[di+3] = 255;
        }
      }
      return dst;
    }

    const kernels = {
      sharpenLite: {
        // Hafif keskinleştirme
        k: [
          0, -0.2, 0,
          -0.2, 2, -0.2,
          0, -0.2, 0
        ], factor: 1, bias: 0
      },
      sharpenStrong: {
        k: [
          0, -1, 0,
          -1, 5, -1,
          0, -1, 0
        ], factor: 1, bias: 0
      },
      edgeBoost: {
        k: [
          -1, -1, -1,
          -1, 8, -1,
          -1, -1, -1
        ], factor: 0.2, bias: 0
      },
      gaussianBlur3: {
        // Basit 3x3 Gaussian blur
        k: [
          1, 2, 1,
          2, 4, 2,
          1, 2, 1
        ], factor: 1/16, bias: 0
      },
      boxBlur3: {
        k: [
          1, 1, 1,
          1, 1, 1,
          1, 1, 1
        ], factor: 1/9, bias: 0
      },
      emboss: {
        k: [
          -2, -1, 0,
          -1, 1, 1,
          0, 1, 2
        ], factor: 1, bias: 128
      }
    };

    const work = document.createElement('canvas');
    const wctx = work.getContext('2d');

    function upscaleAndEnhance(scale, mode) {
      const sw = video.videoWidth; const sh = video.videoHeight;
      if (!sw || !sh) return;

      // 1) Esas yükseltme: Canvas ölçekleme (yakın bicubic görünüm için imageSmoothingQuality = 'high')
      const dw = Math.round(sw * scale);
      const dh = Math.round(sh * scale);

      work.width = dw; work.height = dh;
      wctx.imageSmoothingEnabled = true;
      wctx.imageSmoothingQuality = 'high';
      wctx.drawImage(video, 0, 0, dw, dh);

      // 2) AI-benzeri iyileştirme: kenar ve detay artırma
      const img = wctx.getImageData(0, 0, dw, dh);
      let out = img.data;

      if (mode === 'lite') {
        out = convolveRGBA(out, dw, dh, kernels.sharpenLite.k, kernels.sharpenLite.factor, kernels.sharpenLite.bias);
      } else if (mode === 'quality') {
        // Quality: kenar artır + güçlü keskinleştir
        out = convolveRGBA(out, dw, dh, kernels.edgeBoost.k, kernels.edgeBoost.factor, kernels.edgeBoost.bias);
        out = convolveRGBA(out, dw, dh, kernels.sharpenStrong.k, kernels.sharpenStrong.factor, kernels.sharpenStrong.bias);
      } else if (mode === 'ultra') {
        // Ultra: hafif blur ile gürültüyü bastır, sonra kenar artır + güçlü sharpen (daha yavaş)
        out = convolveRGBA(out, dw, dh, kernels.gaussianBlur3.k, kernels.gaussianBlur3.factor, kernels.gaussianBlur3.bias);
        out = convolveRGBA(out, dw, dh, kernels.edgeBoost.k, kernels.edgeBoost.factor, kernels.edgeBoost.bias);
        out = convolveRGBA(out, dw, dh, kernels.sharpenStrong.k, kernels.sharpenStrong.factor, kernels.sharpenStrong.bias);
      } else if (mode === 'smooth') {
        // Smooth: blur + hafif sharpen (detaylar yumuşak kalır)
        out = convolveRGBA(out, dw, dh, kernels.gaussianBlur3.k, kernels.gaussianBlur3.factor, kernels.gaussianBlur3.bias);
        out = convolveRGBA(out, dw, dh, kernels.sharpenLite.k, kernels.sharpenLite.factor, kernels.sharpenLite.bias);
      } else if (mode === 'denoise') {
        // Denoise: kutu blur ile gürültü azalt, ardından hafif keskinlik geri ver
        out = convolveRGBA(out, dw, dh, kernels.boxBlur3.k, kernels.boxBlur3.factor, kernels.boxBlur3.bias);
        out = convolveRGBA(out, dw, dh, kernels.sharpenLite.k, kernels.sharpenLite.factor, kernels.sharpenLite.bias);
      } else if (mode === 'cartoon') {
        // Cartoon: blur ile alanları düzleştir, kenarları güçlü göster, hafif unsharp etkisi
        out = convolveRGBA(out, dw, dh, kernels.boxBlur3.k, kernels.boxBlur3.factor, kernels.boxBlur3.bias);
        out = convolveRGBA(out, dw, dh, kernels.edgeBoost.k, kernels.edgeBoost.factor, kernels.edgeBoost.bias);
        // küçük bir ek keskinlik aşırılığı engellemek için lite kullan
        out = convolveRGBA(out, dw, dh, kernels.sharpenLite.k, kernels.sharpenLite.factor, kernels.sharpenLite.bias);
      } else if (mode === 'edges') {
        // Yalnızca kenar vurgulu görüntü
        out = convolveRGBA(out, dw, dh, kernels.edgeBoost.k, kernels.edgeBoost.factor, kernels.edgeBoost.bias);
      } else {
        // Varsayılan: quality
        out = convolveRGBA(out, dw, dh, kernels.edgeBoost.k, kernels.edgeBoost.factor, kernels.edgeBoost.bias);
        out = convolveRGBA(out, dw, dh, kernels.sharpenStrong.k, kernels.sharpenStrong.factor, kernels.sharpenStrong.bias);
      }

      const outImg = new ImageData(out, dw, dh);
      wctx.putImageData(outImg, 0, 0);

      // Sonucu asıl canvasa çiz
      canvas.width = dw; canvas.height = dh;
      const cctx = canvas.getContext('2d');
      cctx.drawImage(work, 0, 0);

      // Bilgi metinleri
      origInfo.textContent = `${sw}x${sh}`;
      upInfo.textContent = `${dw}x${dh} | ölçek ${scale}x | model ${mode}`;
    }

    function tick() {
      const scale = parseFloat(scaleSelect.value);
      const model = modelSelect.value;
      upscaleAndEnhance(scale, model);
      anim = requestAnimationFrame(tick);
    }

    startBtn.addEventListener('click', startCamera);
    stopBtn.addEventListener('click', stopCamera);

    navigator.mediaDevices?.getUserMedia?.({ video: true })
      .then(async tmp => {
        tmp.getTracks().forEach(t => t.stop());
        await listCameras();
        status('Hazır');
      })
      .catch(() => {
        // Kullanıcı izin vermeden de cihaz listesi gelmeyebilir; yine de deneyelim
        listCameras();
      });

    // Ölçek veya model değişirse anında etkisini göster
    scaleSelect.addEventListener('change', () => tick());
    modelSelect.addEventListener('change', () => tick());
  </script>
</body>
</html>
